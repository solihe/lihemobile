<!-- Generated by SpecStory -->

# Cursor Rules Generation (2025-04-21 15:24:17)

_**User**_

/generate cursor rules

---

_**Assistant**_



---

<details>
            <summary>Listed current directory • **24** results</summary>
        
| Name |
|-------|
| 📁 `node_modules` |
| 📄 `package-lock.json` |
| 📁 `.cursor` |
| 📁 `docs` |
| 📄 `index.html` |
| 📁 `.git` |
| 📄 `.cursorindexingignore` |
| 📁 `.specstory` |
| 📄 `.gitattributes` |
| 📄 `.gitignore` |
| 📄 `.npmrc` |
| 📄 `Dockerfile` |
| 📄 `eslint.config.js` |
| 📄 `ilihe_mobile_assets.md` |
| 📄 `nginx.conf` |
| 📄 `package.json` |
| 📄 `postcss.config.js` |
| 📁 `public` |
| 📄 `serve-local.bat` |
| 📄 `serve-local.ps1` |
| 📁 `src` |
| 📄 `tailwind.config.js` |
| 📄 `vite.config.js` |
| 📄 `zeabur.json` |

</details>

---

Let me check the Cursor-specific files and directories to understand how cursor rules might be defined.

---

Could not find file '.cursor/'. Did you mean one of:
- .cursor/rules/ui_ux_design.md
- .cursor/rules/laihe_baijiu_main.md
- .cursor/rules/frontend_development.md

---

Now I see there's a `.cursor/rules/` directory with some rule files. Let me check these files to understand the format and content.

---

Read file: .cursor/rules/frontend_development.md

---

Read file: .cursor/rules/ui_ux_design.md

---

Read file: .cursor/rules/laihe_baijiu_main.md

---

Now I understand the format and purpose of Cursor rules. Let me create a comprehensive set of Cursor rules that would be helpful for a development project. I'll create a new rules file that focuses on general cursor rules for effective coding.

---

```diff
- 
+ # Effective Coding with Cursor - Rules & Best Practices
+ 
+ ## 1. General Workflow Optimization
+ 
+ ### Project Navigation
+ - Use `Ctrl+P` for quick file navigation
+ - Use `Ctrl+Shift+F` for global search across the project
+ - Use `/` command menu for accessing Cursor's features without memorizing shortcuts
+ - Utilize the file explorer (`Ctrl+B`) for hierarchical project navigation
+ 
+ ### Code Organization
+ - Keep related files close in the folder structure
+ - Use consistent naming conventions across the project
+ - Maintain a clear separation of concerns in your architecture
+ - Follow the DRY (Don't Repeat Yourself) principle across files
+ 
+ ### Version Control Integration
+ - Use Cursor's Git integration panel for basic operations
+ - Review changes before commits with the diff viewer
+ - Utilize AI to generate meaningful commit messages
+ - Consider using conventional commit format for consistency
+ 
+ ## 2. AI-Enhanced Development
+ 
+ ### Code Generation
+ - Be specific in your AI prompts to get better code suggestions
+ - Review AI-generated code carefully before accepting
+ - Use `/generate` to create new components, functions, or features
+ - Provide context to AI about your codebase for better results
+ 
+ ### Code Understanding
+ - Use `/explain` to understand complex code blocks
+ - Leverage AI to document existing code with `/document`
+ - Ask AI targeted questions about specific parts of your code
+ - Use AI to help refactor code with `/refactor`
+ 
+ ### Debugging Assistance
+ - Ask AI to help identify potential bugs with `/debug`
+ - Have AI explain error messages and suggest solutions
+ - Use AI to generate test cases for better coverage
+ - Request AI to optimize code with performance considerations
+ 
+ ## 3. Editor Efficiency
+ 
+ ### Keyboard Shortcuts
+ - Master multi-cursor editing (`Ctrl+D` for selecting occurrences)
+ - Use `Alt+Up/Down` to move lines vertically
+ - Utilize `Alt+Shift+Up/Down` to duplicate lines
+ - Learn column selection with `Alt+Shift+drag`
+ 
+ ### Code Formatting
+ - Use automated formatting with `Alt+Shift+F`
+ - Configure formatters per language in settings
+ - Set up format-on-save for consistent code style
+ - Use linters to enforce code quality standards
+ 
+ ### Code Navigation
+ - Jump to definition with `F12`
+ - Use `Alt+Left/Right` to navigate backwards/forwards
+ - Navigate to symbols within a file with `Ctrl+Shift+O`
+ - Use breadcrumbs for hierarchical navigation within files
+ 
+ ## 4. Collaborative Development
+ 
+ ### Pair Programming
+ - Use Cursor's live collaboration features when available
+ - Share context with collaborators about current task
+ - Document decisions made during collaborative sessions
+ - Leverage AI assistance during pair programming for knowledge sharing
+ 
+ ### Code Reviews
+ - Use AI to help prepare code review notes
+ - Ask AI to explain unfamiliar code during reviews
+ - Generate test cases for code under review
+ - Document review findings and resolutions
+ 
+ ### Knowledge Sharing
+ - Document complex solutions with AI assistance
+ - Create reusable code snippets for team usage
+ - Use AI to generate explanations for team members
+ - Maintain a shared document of best practices and solutions
+ 
+ ## 5. Language-Specific Optimizations
+ 
+ ### JavaScript/TypeScript
+ - Use AI to help with complex type definitions
+ - Generate utility functions for common operations
+ - Request assistance with React hooks and patterns
+ - Ask for help optimizing bundle size
+ 
+ ### Python
+ - Utilize AI for generating Pythonic solutions
+ - Get help with data structure selection
+ - Ask for optimization of algorithm implementations
+ - Use AI to explain complex libraries and APIs
+ 
+ ### Backend Development
+ - Generate server-side validation rules
+ - Get help designing efficient database schemas
+ - Request assistance with API design principles
+ - Use AI to explain complex backend patterns
+ 
+ ## 6. Testing & Quality Assurance
+ 
+ ### Test Generation
+ - Use `/test` to generate unit tests for functions
+ - Ask AI to identify edge cases for thorough testing
+ - Generate performance tests for critical paths
+ - Request E2E test scenarios for user workflows
+ 
+ ### Code Quality
+ - Use AI to identify code smells and refactoring opportunities
+ - Request security vulnerability checks
+ - Ask for accessibility improvements in front-end code
+ - Generate documentation for public APIs
+ 
+ ### Performance Optimization
+ - Request AI assistance for identifying bottlenecks
+ - Get suggestions for algorithm improvements
+ - Ask for memory optimization techniques
+ - Use AI to explain complex performance patterns
+ 
+ ## 7. Cursor Command Reference
+ 
+ ### Essential Commands
+ - `/`: Open command menu
+ - `/generate`: Create new code
+ - `/explain`: Understand existing code
+ - `/debug`: Find and fix issues
+ - `/refactor`: Improve code structure
+ - `/document`: Add documentation
+ - `/test`: Create tests
+ - `/complete`: Get AI suggestions for completing code
+ 
+ ### Advanced Functions
+ - `/terminal`: Execute terminal commands
+ - `/diff`: Compare files or changes
+ - `/search`: Perform semantic code search
+ - `/translate`: Convert between languages or frameworks
+ - `/optimize`: Improve code performance
+ - `/edit`: Make specific modifications
+ - `/review`: Get feedback on your code
+ 
+ ## 8. Customization & Extension
+ 
+ ### Settings Optimization
+ - Configure Cursor's AI settings for your workflow
+ - Set up language-specific editor configurations
+ - Configure keyboard shortcuts for most-used commands
+ - Adjust theme and appearance for productive coding sessions
+ 
+ ### Snippets & Templates
+ - Create custom snippets for frequent patterns
+ - Use AI to generate project-specific templates
+ - Build a library of reusable code components
+ - Develop consistent documentation templates
+ 
+ ### Integration with Tools
+ - Configure Cursor to work with your linters and formatters
+ - Set up integration with CI/CD workflows
+ - Connect with external documentation systems
+ - Utilize external AI services when beneficial 
```

---

Let me create a second Cursor rules file focused on AI-specific best practices for coding.

---

```diff
- 
+ # AI Coding Best Practices in Cursor
+ 
+ ## 1. Effective AI Prompting
+ 
+ ### Clarity and Specificity
+ - Be detailed about what you want to accomplish
+ - Include relevant technical context and constraints
+ - Specify programming language, frameworks, and libraries
+ - Mention performance expectations or other requirements
+ 
+ ### Iterative Refinement
+ - Start with a broad request, then refine iteratively
+ - Provide feedback on what works and what doesn't
+ - Build on previous successful interactions
+ - Reference previous code or responses when appropriate
+ 
+ ### Context Management
+ - Use `/context` to provide additional project information
+ - Include relevant documentation links when needed
+ - Explain business logic or domain-specific knowledge
+ - Specify coding standards and patterns to follow
+ 
+ ## 2. Code Generation Strategies
+ 
+ ### Component Creation
+ - Describe the component's purpose and functionality
+ - Specify props/inputs and expected outputs
+ - Mention styling approach (CSS modules, styled-components, etc.)
+ - Include accessibility requirements
+ 
+ ### Function Implementation
+ - Clearly define inputs, outputs, and edge cases
+ - Specify error handling expectations
+ - Mention performance considerations if relevant
+ - Describe the algorithm or approach you want
+ 
+ ### API Integration
+ - Provide API documentation or endpoint details
+ - Specify authentication requirements
+ - Describe error handling and retry strategies
+ - Mention data transformation needs
+ 
+ ## 3. Code Improvement Techniques
+ 
+ ### Refactoring Requests
+ - Identify specific code smells or issues to address
+ - Specify refactoring goals (performance, readability, etc.)
+ - Provide context about surrounding code
+ - Set constraints (e.g., "maintain backward compatibility")
+ 
+ ### Performance Optimization
+ - Profile your code first to identify bottlenecks
+ - Share performance metrics or issues observed
+ - Specify target platforms or environments
+ - Mention acceptable trade-offs (memory vs. speed)
+ 
+ ### Bug Fixing
+ - Describe the exact error or unexpected behavior
+ - Share error messages, stack traces, or logs
+ - Explain expected behavior
+ - Provide steps to reproduce the issue
+ 
+ ## 4. Learning from AI
+ 
+ ### Code Explanations
+ - Ask for line-by-line explanations of complex code
+ - Request conceptual overviews of algorithms or patterns
+ - Ask about alternative approaches and their trade-offs
+ - Use AI to understand unfamiliar libraries or APIs
+ 
+ ### Best Practices
+ - Ask for idiomatic code in specific languages
+ - Request security best practices for your context
+ - Learn about optimization techniques
+ - Inquire about testing strategies
+ 
+ ### Skill Development
+ - Have AI explain concepts progressively
+ - Request exercises to practice specific skills
+ - Ask for code reviews to improve your code
+ - Use AI to explore new technologies methodically
+ 
+ ## 5. Project-Specific AI Usage
+ 
+ ### Documentation Generation
+ - Have AI generate docstrings or comments
+ - Create README files or setup instructions
+ - Document API endpoints or interfaces
+ - Generate user guides or developer documentation
+ 
+ ### Testing Assistance
+ - Generate unit tests with good coverage
+ - Create test fixtures or mock data
+ - Implement integration or end-to-end tests
+ - Design test strategies for complex systems
+ 
+ ### Architecture Planning
+ - Discuss system design options with AI
+ - Create diagrams or architecture documents
+ - Evaluate different architectural patterns
+ - Plan migration strategies or refactorings
+ 
+ ## 6. AI Collaboration Patterns
+ 
+ ### Pair Programming with AI
+ - Use AI as a coding partner for rapid development
+ - Have AI review your code in real-time
+ - Discuss implementation approaches before coding
+ - Debug problems collaboratively
+ 
+ ### Code Reviews
+ - Have AI review pull requests or commits
+ - Ask for specific feedback areas (performance, security, etc.)
+ - Use AI to suggest improvements
+ - Generate review checklists for different types of code
+ 
+ ### Knowledge Transfer
+ - Document complex systems with AI assistance
+ - Create onboarding materials for new team members
+ - Generate explanations of legacy code
+ - Build shared knowledge bases of solutions
+ 
+ ## 7. Advanced AI Techniques
+ 
+ ### Multi-Step Problems
+ - Break down complex tasks into smaller steps
+ - Have AI generate a plan before implementation
+ - Maintain context across multiple interactions
+ - Build solutions incrementally with feedback loops
+ 
+ ### Code Generation Templates
+ - Create reusable templates for common patterns
+ - Define clear placeholders for customization
+ - Document how to adapt templates for different cases
+ - Maintain a library of successful prompts
+ 
+ ### Framework-Specific Strategies
+ - Learn framework-specific prompt patterns
+ - Mention version constraints and compatibility
+ - Reference official documentation or patterns
+ - Specify framework-specific best practices
+ 
+ ## 8. AI Limitations and Workarounds
+ 
+ ### Handling Large Codebases
+ - Share only relevant snippets rather than entire files
+ - Provide summaries of complex systems
+ - Use links to GitHub or other repositories when possible
+ - Maintain context through consistent reference points
+ 
+ ### Managing AI Hallucinations
+ - Verify generated code against documentation
+ - Test AI solutions thoroughly
+ - Be specific about requirements to reduce ambiguity
+ - Cross-check with multiple sources for critical code
+ 
+ ### Dealing with Context Limits
+ - Split large requests into manageable chunks
+ - Reference previous messages instead of repeating
+ - Maintain consistent terminology across interactions
+ - Summarize previous context when starting new sessions
+ 
+ ## 9. AI Ethics and Best Practices
+ 
+ ### Code Quality
+ - Don't accept AI-generated code without review
+ - Understand the code you're integrating
+ - Test AI solutions thoroughly
+ - Maintain coding standards even with AI assistance
+ 
+ ### Security Considerations
+ - Review AI-generated code for security vulnerabilities
+ - Never share sensitive data or credentials with AI
+ - Validate security-critical implementations
+ - Follow security best practices consistently
+ 
+ ### Attribution and Licensing
+ - Understand licensing implications of AI-generated code
+ - Document sources and inspirations appropriately
+ - Follow your organization's policies for AI use
+ - Consider open source contributions and attribution 
```

---

Let me create one final Cursor rules file for project-specific coding standards:

---

```diff
- 
+ # Project Coding Standards for Cursor
+ 
+ ## 1. Code Organization
+ 
+ ### File Structure
+ - Organize files by feature rather than by type
+ - Keep related files (components, styles, tests) together
+ - Limit file size to maintain readability (~300 lines max)
+ - Use index.js files for cleaner imports
+ 
+ ### Component Structure 
+ - Follow a consistent component structure:
+   1. Imports
+   2. Type definitions
+   3. Constants
+   4. Component function
+   5. Helper functions
+   6. Exports
+ - Use named exports for better import control
+ - Extract complex logic to separate utility files
+ 
+ ### Code Formatting
+ - Use consistent indentation (2 spaces recommended)
+ - Maintain a maximum line length of 80-100 characters
+ - Use meaningful whitespace to separate logical blocks
+ - Format code with ESLint/Prettier before committing
+ 
+ ## 2. Naming Conventions
+ 
+ ### Variables and Functions
+ - Use camelCase for variables and function names
+ - Choose descriptive names that reflect purpose
+ - Avoid abbreviations unless universally understood
+ - Prefix boolean variables with "is", "has", or "should"
+ 
+ ### Components and Classes
+ - Use PascalCase for component names and classes
+ - Name components after their primary responsibility
+ - Ensure names are descriptive but concise
+ - Follow consistent naming patterns within feature areas
+ 
+ ### Files and Directories
+ - Use kebab-case for file and directory names
+ - Name files after their primary export
+ - Use consistent suffixes (.component.js, .test.js, etc.)
+ - Group related files in descriptive directories
+ 
+ ## 3. JavaScript/TypeScript Standards
+ 
+ ### Type Safety
+ - Use TypeScript for all new code
+ - Define explicit types for function parameters and returns
+ - Avoid using `any` type except when absolutely necessary
+ - Create interfaces for complex data structures
+ 
+ ### Modern JavaScript
+ - Use ES6+ features (arrow functions, destructuring, etc.)
+ - Prefer const for variables that don't reassign
+ - Use let for variables that need reassignment
+ - Avoid var in all new code
+ 
+ ### Async Patterns
+ - Use async/await for asynchronous operations
+ - Handle errors with try/catch blocks
+ - Provide meaningful error messages
+ - Avoid deeply nested callbacks or promises
+ 
+ ## 4. React Best Practices
+ 
+ ### Component Design
+ - Create small, focused components with single responsibilities
+ - Use functional components with hooks instead of class components
+ - Extract reusable logic into custom hooks
+ - Minimize component nesting to reduce complexity
+ 
+ ### Props Management
+ - Define prop types for all components
+ - Provide default props where appropriate
+ - Use prop destructuring in function parameters
+ - Group related props into objects to reduce prop count
+ 
+ ### State Management
+ - Keep state as local as possible
+ - Use context for truly global state
+ - Consider state management libraries only when necessary
+ - Implement proper loading and error states
+ 
+ ### Performance Optimization
+ - Use React.memo for pure functional components
+ - Implement useCallback for functions passed as props
+ - Use useMemo for expensive calculations
+ - Avoid unnecessary renders with proper dependency arrays
+ 
+ ## 5. CSS and Styling
+ 
+ ### CSS Organization
+ - Use CSS-in-JS or CSS Modules for component styling
+ - Organize styles from general to specific
+ - Follow a consistent naming convention (BEM recommended)
+ - Avoid deeply nested selectors
+ 
+ ### Responsive Design
+ - Use relative units (rem, em, %) for better responsiveness
+ - Implement mobile-first design approach
+ - Use media queries consistently
+ - Test on various screen sizes and devices
+ 
+ ### Theme Management
+ - Centralize design tokens (colors, spacing, etc.)
+ - Use a theme provider for consistent styling
+ - Create a design system with reusable UI components
+ - Document design patterns and usage guidelines
+ 
+ ## 6. Testing Standards
+ 
+ ### Unit Testing
+ - Aim for meaningful test coverage (70%+ recommended)
+ - Follow the AAA pattern (Arrange, Act, Assert)
+ - Test component behavior, not implementation details
+ - Mock external dependencies appropriately
+ 
+ ### Component Testing
+ - Test component rendering and user interactions
+ - Verify accessibility requirements
+ - Test edge cases and error states
+ - Use snapshot testing judiciously
+ 
+ ### Integration Testing
+ - Test interactions between components
+ - Verify data flow through the application
+ - Test API integrations with appropriate mocks
+ - Focus on user workflows and journeys
+ 
+ ## 7. Documentation Standards
+ 
+ ### Code Comments
+ - Add comments for complex logic or non-obvious decisions
+ - Document workarounds or temporary solutions
+ - Include references to issues or requirements
+ - Use JSDoc format for function documentation
+ 
+ ### Component Documentation
+ - Document component props and usage examples
+ - Explain component variations and states
+ - Include accessibility considerations
+ - Consider using Storybook for visual documentation
+ 
+ ### Project Documentation
+ - Maintain an up-to-date README with setup instructions
+ - Document architecture decisions and patterns
+ - Create onboarding guides for new developers
+ - Keep documentation in sync with code changes
+ 
+ ## 8. Performance Standards
+ 
+ ### Loading Performance
+ - Optimize bundle size with code splitting
+ - Implement lazy loading for non-critical components
+ - Optimize and compress assets (images, fonts, etc.)
+ - Use performance monitoring tools
+ 
+ ### Runtime Performance
+ - Avoid expensive operations in render methods
+ - Implement virtualization for long lists
+ - Optimize re-renders with proper React patterns
+ - Use web workers for CPU-intensive tasks
+ 
+ ### Memory Management
+ - Clean up subscriptions and event listeners
+ - Avoid memory leaks in components
+ - Use appropriate data structures for efficiency
+ - Implement pagination for large data sets
+ 
+ ## 9. Accessibility Standards
+ 
+ ### Semantic HTML
+ - Use appropriate HTML elements for their intended purpose
+ - Implement proper heading hierarchy
+ - Use landmarks for major page sections
+ - Ensure logical document structure
+ 
+ ### Keyboard Navigation
+ - Ensure all interactive elements are keyboard accessible
+ - Implement proper focus management
+ - Use tabindex appropriately
+ - Test keyboard navigation flows
+ 
+ ### Screen Readers
+ - Add appropriate ARIA attributes when needed
+ - Provide alt text for images and meaningful labels
+ - Test with screen readers
+ - Fix accessibility issues promptly
+ 
+ ### Visual Design
+ - Ensure sufficient color contrast
+ - Don't rely solely on color for conveying information
+ - Make text resizable without breaking layouts
+ - Support zoom and text scaling
+ 
+ ## 10. Security Standards
+ 
+ ### Data Handling
+ - Sanitize user inputs to prevent XSS attacks
+ - Avoid storing sensitive data in client-side storage
+ - Implement proper authentication and authorization
+ - Use HTTPS for all API requests
+ 
+ ### Dependency Management
+ - Regularly update dependencies
+ - Run security audits on dependencies
+ - Remove unused dependencies
+ - Pin dependency versions for stability
+ 
+ ### Code Security
+ - Avoid eval() and similar functions
+ - Implement proper Content Security Policies
+ - Use security headers appropriately
+ - Follow OWASP security guidelines 
```

---

I've created three comprehensive Cursor rules files to enhance your development workflow:

1. `.cursor/rules/effective_coding.md` - General workflow optimization, keyboard shortcuts, and productivity tips for Cursor IDE.

2. `.cursor/rules/ai_coding_best_practices.md` - Best practices for effective AI prompting, code generation, and collaboration with AI.

3. `.cursor/rules/project_coding_standards.md` - Comprehensive coding standards for maintaining high-quality, consistent code across your project.

These rules provide a solid foundation for efficient development in Cursor, covering everything from basic navigation to advanced AI collaboration techniques and project-specific coding standards.

---



---

